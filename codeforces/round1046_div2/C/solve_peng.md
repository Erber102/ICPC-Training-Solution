# C. Against the Difference
## 基本信息
- **比赛**：cf round1046 div2
- **题目状态**：赛后补题
- **补题日期**：2025-8-30
- **题目链接**：https://codeforces.com/contest/2136/problem/C
- **难度**：easy
- **标签**：[[线性dp]]
- **相似题**：{{题号或纯文本链接（如有）}}

---

## 题意简述
给定长度为$n$的数组$a$。定义：如果一个数组中每个元素的值都与这个数组大小相同，那么这个数组是一个块(block)。找到数组$a$最长的由块组成的子数组长度。
$1 \le n \le 2 \cdot 10^{5}, 1 \le a_{i} \le n$

---

## 解题过程

### 初始思路
- 我一开始打算怎么做？  用动态规划
- 卡在哪一步？无法给出划分和状态转移方程
- 有没有做时间复杂度 / 数据范围的初步判断？$O(n)$

### 错误原因
- 如果是实现问题，写出导致错误的具体代码片段或思路处。
```cpp
if (vec[a[i]].size() - a[i] < 0) ans[i] = -1;
```
这里是恒false的条件，因为`.size()`返回类型是`unsigned long long`，所以左边的类型是unsigned，正确写法是`if (vec[a[i]].size() < a[i])`

### 正确解法
- **核心思路**（用自己的话）：  
  1. 步骤一：状态划分，定义`dp[i]`为$[0,i)$区间内最长满足条件的子数组的长度（局部满足条件）
  2. 步骤二：状态转移方程，考虑两种情况，不选择$a_i$，选择$a_i$（成块）。$dp[i + 1] = max(dp[i],dp[x] + a_i)$，其中$x$是所有$a_i$中第$a_i$大的位置下标
  3. 步骤三：找$x$。我们需要用到一个辅助数组，来记录每个位置的$x$值。
- **复杂度分析**：时间 $O(n)$，空间 $O(n)$  
- **为什么能通过**：状态转移方程的建立，可以从初始状态线性推导出其他状态

### 模板 / 关键代码
```cpp
//ans作为辅助数组记录x值
for (int i = 0; i < n; i++) {
        cin >> a[i];
        vec[a[i]].push_back(i);
        if (vec[a[i]].size() < a[i]) ans[i] = -1;
        else ans[i] = vec[a[i]][vec[a[i]].size() - a[i]];
}

//dp过程
dp[0] = a[0] == 1 ? 1 : 0;
for (int i = 1; i < n; i++) {
	if (ans[i] < 0) dp[i] = dp[i - 1];
	else if (ans[i] == 0) dp[i] = max(a[i],dp[i-1]);
	else dp[i] = max(dp[i - 1], dp[ans[i] - 1] + a[i]);
}
````

---

## 复盘总结

* **核心模型**：线性dp
* **关键突破口**：分类情况：$a_i$是否在目标子数组中从而建立状态转移方程
* **坑点 / 易错点**：不会建立线性dp的转移方程 -> 分情况讨论边界对结果的贡献

---
